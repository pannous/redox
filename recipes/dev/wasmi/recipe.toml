[source]
git = "https://github.com/wasmi-labs/wasmi.git"
branch = "main"

[build]
template = "custom"
script = """
# Build wasmi CLI runner
mkdir -p "${COOKBOOK_SOURCE}/runner"
cat > "${COOKBOOK_SOURCE}/runner/Cargo.toml" << 'EOF'
[package]
name = "wasmi-runner"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "wasmi-run"
path = "src/main.rs"

[dependencies]
wasmi = { path = "../", default-features = false, features = ["std"] }
anyhow = "1"
EOF

mkdir -p "${COOKBOOK_SOURCE}/runner/src"
cat > "${COOKBOOK_SOURCE}/runner/src/main.rs" << 'EOF'
use anyhow::{Context, Result};
use std::fs;
use wasmi::*;

fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: {} <wasm_file> [function_name]", args[0]);
        std::process::exit(1);
    }

    let wasm_path = &args[1];
    let func_name = args.get(2).map(|s| s.as_str()).unwrap_or("main");

    let wasm_bytes = fs::read(wasm_path)
        .context("Failed to read WASM file")?;

    let engine = Engine::default();
    let module = Module::new(&engine, &wasm_bytes[..])
        .context("Failed to parse WASM module")?;

    let mut store = Store::new(&engine, ());
    let instance = Instance::new(&mut store, &module, &[])
        .context("Failed to instantiate module")?;

    // Try to call the specified function
    if let Some(export) = instance.get_export(&store, func_name) {
        if let Some(func) = export.into_func() {
            let mut results = vec![Val::I32(0)];
            let params = vec![Val::I32(0)]; // Default param
            func.call(&mut store, &params, &mut results)?;

            // Print the result
            match &results[0] {
                Val::I32(v) => println!("{}", v),
                Val::I64(v) => println!("{}", v),
                Val::F32(v) => println!("{}", f32::from_bits(v.to_bits())),
                Val::F64(v) => println!("{}", f64::from_bits(v.to_bits())),
                _ => {}
            }
        }
    } else if let Some(start) = instance.get_export(&store, "_start") {
        if let Some(func) = start.into_func() {
            let _ = func.call(&mut store, &[], &mut []);
        }
    }

    Ok(())
}
EOF

# Configure cargo for Redox target
mkdir -p "${COOKBOOK_SOURCE}/runner/.cargo"
cat > "${COOKBOOK_SOURCE}/runner/.cargo/config.toml" << EOF
[target.${TARGET}]
linker = "rust-lld"
rustflags = ["-C", "link-arg=-L${COOKBOOK_SYSROOT}/lib", "-C", "link-arg=${COOKBOOK_SYSROOT}/lib/crt0.o", "-C", "link-arg=${COOKBOOK_SYSROOT}/lib/crti.o", "-C", "link-arg=-lc", "-C", "link-arg=${COOKBOOK_SYSROOT}/lib/crtn.o"]
EOF

# Build wasmi runner
cd "${COOKBOOK_SOURCE}/runner"
"${COOKBOOK_CARGO}" build \
    --config net.offline=false \
    -Zbuild-std=std,panic_abort \
    --target "${TARGET}" \
    --release

mkdir -pv "${COOKBOOK_STAGE}/usr/bin"
cp -v "target/${TARGET}/release/wasmi-run" "${COOKBOOK_STAGE}/usr/bin/"
"""
